package com.edgeburnmedia.customloottables;

import org.bukkit.NamespacedKey;
import org.bukkit.inventory.Inventory;
import org.bukkit.inventory.ItemStack;
import org.bukkit.loot.LootContext;
import org.bukkit.loot.LootTable;

import javax.annotation.Nullable;
import java.util.*;

/**
 * Custom {@link LootTable} that reads from {@code custom_loot_tables.yml}
 *
 * @author Edgeburn Media
 */
public class CustomLootTable implements LootTable {
	private final CustomLootTables plugin;
	private final UUID uuid;
	private ArrayList<LootItem> loot = new ArrayList<>();
	private String replaces;

	public CustomLootTable(CustomLootTables plugin, LootItem... loot) {
		this(plugin, UUID.randomUUID(), loot);
	}

	/**
	 * Initialize a CustomLootTable with an existing UUID. <br>
	 * Should be used when initializing
	 *
	 * @param plugin Reference to the main plugin object
	 * @param uuid   UUID as defined in the config file
	 * @param loot   Loot this CustomLootTable contains. Should be read from the config file when initializing with a
	 *               UUID
	 */
	public CustomLootTable(CustomLootTables plugin, UUID uuid, LootItem... loot) {
		this.plugin = plugin;
		this.loot.addAll(Arrays.asList(loot));
		this.uuid = uuid;
	}

	public CustomLootTables getPlugin() {
		return plugin;
	}

	public @Nullable
	String getReplaces() {
		return replaces;
	}

	public void setReplaces(@Nullable String replaces) {
		this.replaces = replaces;
	}

	@Override
	public Collection<ItemStack> populateLoot(Random random, LootContext context) {
		ArrayList<ItemStack> generatedLoot = new ArrayList<>();
		plugin.getDebuggingLogger().log("attempting to generate " + loot.size() + " items");

		for (LootItem item : loot) {
			ItemStack generatedItem = item.getRandomly();
			if (generatedItem != null) { // null represents that no item was generated [based on random chance], so don't add it to the generated loot
				generatedLoot.add(generatedItem);
			}
		}

		plugin.getDebuggingLogger().log("generated " + generatedLoot.size() + " items");
		return generatedLoot;
	}

	/**
	 * Fill a given {@link Inventory} with the items generated by {@link CustomLootTable#populateLoot(Random random, LootContext context)}.
	 * Does not do any additional work, rather simply runs {@link Inventory#addItem(ItemStack... items)} and puts items into the inventory as-is.
	 *
	 * @param inventory Inventory to fill with loot
	 * @param random    Random object
	 * @param context   Loot context
	 * @deprecated Use of {@link CustomLootTable#fillInventoryMerged(Inventory inventory, Random random, LootContext context, LootTable originalLootTable)} is preferred.
	 */
	@Override
	public void fillInventory(Inventory inventory, Random random, LootContext context) {
		ItemStack[] lootItems = populateLoot(random, context).toArray(new ItemStack[0]);
		inventory.addItem(lootItems);
	}

	/**
	 * Merge loot from an existing {@link LootTable} with the loot of this custom one. <br><br>
	 * Should be used for generating chest loot.
	 *
	 * @param random            Random object
	 * @param context           {@link LootContext} for generating both sets of loot
	 * @param originalLootTable Original {@link LootTable} to retrieve loot from
	 * @return Loot merged from {@code originalLootTable} and this {@link CustomLootTable}
	 */
	public Collection<ItemStack> getMergedLoot(Random random, LootContext context, LootTable originalLootTable) {
		// array of items to be used as the final list of items
		ArrayList<ItemStack> lootItems = new ArrayList<>();

		ArrayList<ItemStack> newLoot = (ArrayList<ItemStack>) populateLoot(random, context);
		ArrayList<ItemStack> originalLoot = (ArrayList<ItemStack>) originalLootTable.populateLoot(random, context);

		lootItems.addAll(newLoot); // insert the new items
		lootItems.addAll(originalLoot); // insert the original items

		plugin.getDebuggingLogger().log("merging " + originalLoot.size() + " items in original " + originalLootTable.getKey().getKey() + " loot with " + newLoot.size() + " new items");

		return lootItems;
	}
	
	/**
	 * Merge existing generated loot with the loot of this {@link CustomLootTable}.<br><br>
	 * Should be used for generating mob drop loot.
	 *
	 * @param random        Random object
	 * @param context       {@link LootContext} for generating both sets of loot
	 * @param originalItems List of original items from the original loot generation
	 * @return A Collection of the merged loot
	 */
	public Collection<ItemStack> getMergedLoot(Random random, LootContext context, ItemStack... originalItems) {
		ArrayList<ItemStack> lootItems = new ArrayList<>();

		ArrayList<ItemStack> newLoot = (ArrayList<ItemStack>) populateLoot(random, context);

		lootItems.addAll(List.of(originalItems));
		lootItems.addAll(newLoot);

		plugin.getDebuggingLogger().log("merging " + originalItems.length + " items in original loot with " + newLoot.size() + " new items");

		return lootItems;
	}

	/**
	 * Fill a given {@link Inventory} with the items generated by {@link CustomLootTable#getMergedLoot(Random random, LootContext context, LootTable originalLootTable)}.
	 * Does not do any additional work, rather simply runs {@link Inventory#addItem(ItemStack... items)} and puts items into the inventory as-is.<br><br>
	 * <b style="color:orange;">IMPORTANT: Clears the inventory before then adding the newly generated loot</b>
	 *
	 * @param inventory         Inventory to fill with loot
	 * @param random            Random object
	 * @param context           Loot context
	 * @param originalLootTable {@link LootTable} to get original items from
	 */
	public void fillInventoryMerged(Inventory inventory, Random random, LootContext context, LootTable originalLootTable) {
		ItemStack[] lootItems = getMergedLoot(random, context, originalLootTable).toArray(new ItemStack[0]);
		inventory.clear();
		inventory.addItem(lootItems);
	}

	@Override
	public NamespacedKey getKey() {
		return plugin.getCustomLootTablesNamespace();
	}

	public ArrayList<LootItem> getLoot() {
		return loot;
	}

	public void setLoot(ArrayList<LootItem> loot) {
		this.loot = loot;
	}

	public void addLoot(LootItem l) {
		loot.add(l);
	}

	public UUID getUuid() {
		return uuid;
	}
}
